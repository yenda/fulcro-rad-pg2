= SQL Database Plugin

A PostgreSQL plugin for Fulcro RAD using the pg2 driver.

image:https://img.shields.io/clojars/v/com.fulcrologic/fulcro-rad-sql.svg[link=https://clojars.org/com.fulcrologic/fulcro-rad-sql]

== Configuration

In order to use the SQL plugin you must configure connection pools and optionally enable schema management.

The general layout of a config (which commonly includes `config/defaults.edn` on your classpath) should include:

[source,clojure]
-----
...
 :com.fulcrologic.rad.database-adapters.sql/databases
   {:main {:sql/schema :production}}
...
-----

The primary keys in the databases section are database names.
You may have any number of databases in your application.
Each database uses a schema name, which defines which attributes in your model belong in that database.

This allows you to do things like create more than one database with the same schema and shard users across them.

=== Database Connection Pools

This library uses the pg2 PostgreSQL driver for connection pooling.

[source,clojure]
-----
(ns com.example.components.connection-pools
  (:require
    [mount.core :refer [defstate]]
    [com.fulcrologic.rad.database-adapters.sql.pg2 :as pg2]
    [pg.pool :as pg.pool]))

(def pg2-config
  {:host "localhost"
   :port 5432
   :user "user"
   :password "password"
   :database "mydb"})

(defstate connection-pools
  :start
  {:production (pg2/create-pool! pg2-config)}
  :stop
  (pg2/stop-connection-pools! connection-pools))
-----

The configuration options for the SQL adapter look like this:

[source]
-----
 :com.fulcrologic.rad.database-adapters.sql/databases
   {:main {:pg2/config {:host "localhost"
                        :port 5432
                        :user "myuser"
                        :password "mypassword"
                        :database "mydb"}
           :pg2/pool {:pool-min-size 2
                      :pool-max-size 10}
           :sql/auto-create-missing? true
           :sql/schema :production}}
-----

=== Schema Generation

Automatic schema is quite nice for early development work, and is enabled with the `auto-create-missing?` flag.

Each database should be given an (invented) schema name, which will match the schema you set on (some or all) attributes.

The automatic schema generation just tries to generate columns in tables if (and only if) they do not already exist.
This is reasonable for really fast startup of a project, but is almost certainly insufficient for real projects.

For production use, manage your schema with a migration tool of your choice (e.g., Flyway, Migratus, or plain SQL scripts).
The `com.fulcrologic.rad.database-adapters.sql.migration/automatic-schema` function can generate DDL statements
that you can use as a starting point for your migrations

== Attributes

RAD attributes that will be used in an SQL database can be configured as follows (where the sql namespace is `com.fulcrologic.rad.database-adapters.sql`):

`::attr/schema`:: (required) A keyword that matches the schema you want to store the attribute on.
`::attr/identities`:: (required on non-identity attributes) A set of keyword (names) of the id attributes
that identify tables for which this attribute is a row.
`::sql/column-name`:: (optional) A string to use to override the automatic column name.
`::sql/table-name`:: (optional, but only on identity attributes) A string. Overrides the table name that goes
with a given identity attribute.

== Resolvers and Save Middleware [[Resolvers]]

The library supports generation of batched Pathom3 resolvers that can run queries against PostgreSQL tables.

There is also save middleware that handles form saves via the SQL adapter.

=== Save Middleware

[source,clojure]
-----
(ns com.example.components.save-middleware
  (:require
    [com.fulcrologic.rad.database-adapters.sql.plugin :as sql-plugin]))

(def middleware
  (-> (sql-plugin/wrap-sql-save)
      ;; add other middleware here
      ))
-----

=== SQL Resolvers

[source,clojure]
-----
(ns com.example.components.auto-resolvers
  (:require
    [com.example.model :refer [all-attributes]]
    [mount.core :refer [defstate]]
    [com.fulcrologic.rad.resolvers :as res]
    [com.fulcrologic.rad.database-adapters.sql.read :as sql-read]))

(defstate automatic-resolvers
  :start
  (vec
    (concat
      ;; custom resolvers that are declared on attributes
      (res/generate-resolvers all-attributes)
      ;; SQL resolvers for PostgreSQL
      (sql-read/generate-resolvers all-attributes :production))))
-----

If you have more than one schema, simply call `sql-read/generate-resolvers` once for each schema.
It returns a sequence of resolvers that can be installed into your parser.

== The Parser

The central element of the entire back-end is the Pathom Parser. Give the above definitions it will look
something like this:

[source,clojure]
-----
(ns com.example.components.parser
  (:require
    [com.example.components.auto-resolvers :refer [automatic-resolvers]]
    [com.example.components.config :refer [config]]
    [com.example.components.connection-pools :as pools]
    [com.fulcrologic.rad.database-adapters.sql.plugin :as sql]
    [com.fulcrologic.rad.pathom :as pathom]
    [com.fulcrologic.rad.form :as form]
    [com.fulcrologic.rad.blob :as blob]
    [com.example.components.blob-store :as bs]
    [com.example.components.save-middleware :as save]
    [com.example.components.delete-middleware :as delete]
    [mount.core :refer [defstate]]
    [com.example.model :refer [all-attributes]]
    [com.example.model.account :as account]
    [com.example.model.timezone :as timezone]
    [com.fulcrologic.rad.attributes :as rad.attr]
    [com.example.model.invoice :as invoice]))

(defstate parser
  :start
  (pathom/new-parser config
    [(rad.attr/pathom-plugin all-attributes)
     (form/pathom-plugin save/middleware delete/middleware)
     (sql/pathom-plugin (fn [_] {:production (:main pools/connection-pools)}) config)]
    [automatic-resolvers
     form/resolvers
     ...]))
-----

== LICENSE

The MIT License (MIT)
Copyright (c), Fulcrologic, LLC

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
